## 圆月行
![](https://i.imgur.com/UzmuUvx.png)

圆月行基于Java进行开发，开发时间从2018年8月10日至今。

该项目的构建主要有如下几个目的：

- 第一个按照自己想法构建的开源项目
- 上线应用商店
- 熟悉Android体系和Java体系的知识点，提升代码操作的熟练度

项目分为了两个服务后台和一个客户端，客户端和后台的主要业务逻辑由我负责进行开发，后期加入了在校小伙伴LYJ，业务逻辑详见下面的模块开发板块。

至今为止构建的代码量超过35000+行，技术点包括四大组件，UI构建，简单的自定义View，网络编程等。

开发过程中遇到了无数bug，部分在Bug记录模块有所记录，部分归纳成博文放在博客页面-->[张晓翼的博客](https://www.zxyblog.xyz)

## 一.功能介绍

这里配合图文介绍项目的主要功能

## 二.三方依赖

- MobSDK
- 高德MapSDK
- 环信SDK（后期将剔除对于环信的依赖，自己搭建聊天通讯后台）
- CircleImageView
- RecyclerView
- FanLayoutManager
- CardView
- Volley
- Material-Dialog
- LitePal
- ENViews
- Fast Android Networking
- Gson
- LeakCanary
- Ucrop
- Glide
- RxJava
- Retrofit
- AsynHttp

## 三.模块开发

### 登陆注册

### 图片上传

### 数据初始化

### 即时通信

### 自定义View

### 地点探寻

### 算法家族

### 数据三级缓存

### 图片三级缓存

### 内存泄漏处理

### MVP架构模块

## 四.开发流程

> 您可以在这里看到项目的整个开发流程

任务描述：项目构建完成，初始化设计理念，构想完整的页面逻辑，并利用工具（墨刀）开始打造圆月UI界面。

完成时间：*7/31/2018*

***

任务描述：墨刀打造UI界面基本完成，未进行效果优化，开始编写结构代码。

完成时间：*8/4/2018*

***

任务描述：引导页+登录页面基本完成，注册页面完成，注册功能尚未完善，预计引入第三方登录（QQ、微信和微博登录）。

完成时间：*8/12/2018*

***

任务描述：主页面架构大体完成，利用Fragment嵌套和切换，实现侧滑菜单中的菜单项共联，构想六层菜单栏。

完成时间：*8/15/2018 *

***

任务描述：面对抽象的架构完成，开始面对细节的设计项目。

完成时间：*8/18/2018*

***

任务描述：聊天页面搭载完成，暂定客服页面使用聊天页面的窗口，数据的传输尚未实现，平台架构尚未搭建好，预计一个月内实现数据的上传和交互。

完成时间：*8/21/2018*

***

任务描述：背包界面设计完成，采用网格布局，内置功能尚未完成，方格采用ImageView的组件实现，物品栏目使用前景进行填充，并对每个item进行监控，点击后进行弹窗，尚未进行设置。

完成时间：*8/23/2018*

***

任务描述：解决Butterknife与android 3.0冲突的问题，成功使用Butterknife Zeleny插件，减少了每个页面要写findViewById()的冗杂。

完成时间：*2018/9/6*

***

任务描述：使用Mob平台的短信SDK，动态架构进需要使用的gradle配置层，并且在登陆页面实现手机验证的功能。（后期经过验证，mob的SDK在编译时会占用大量的时间，实质上mob页面已经完成，但是sdk不大稳定，有自己实现短信验证的打算，但是与第三方(电信，联通，移动)交互过于麻烦，暂且搁置。）

完成时间：*2018/9/7 *

***

任务描述：使用mvp架构模式对整个项目进行重构，将所有文件区分为区块-逻辑块(Module) + Presenter(桥街块) + View（视图）三块
实现逻辑和视图的高度欠耦合，presenter中间件的作用明显，但是没有用到其它的设计模式导致整个项目的架构看起来还是有些冗杂。

完成时间：*2018/9/16-22*

***

任务描述：有意识的使用动画开始改进当前项目的显示下过，改进所有按钮点击的效果，不再通过来回的改变TextView的Size大小或者改变button本身的颜色来达到点击效果，而是通过button的晃动效果实现用户的优良体验，但是没有规范化各个显示组件的样式和动画模式。

完成时间：*2018/9/21*

***

任务描述：Login-MVP架构模式完全完成，对mvp架构模式逐渐有了自己的理解。

完成时间：*2018/9/25*

***

任务描述：开始实现社交板块，社交板块计划用环信的SDK，并在接下来的几天中完成了对环信SDK的搭载和接入（ps:环信的服务器端和客户端接口做的很不错，token的设置也的确一定程度上的保障了用户数据的安全性，唯一缺陷是价格过高，如果不升级为专业版本就无法上市[因为社区版本最多只有100个用户的注册名额]）

完成时间：*2018/10/1*

***

任务描述：消息接收流程尚在处理，对于用户大量网络数据的保存计划集成在本地的sqlite数据库中，计划使用开源库:GreenDao数据库框架对用户的好友等信息进行保存，理由是每次从网络上获取好友的信息太过耗费时间，也耗费流量，极大程度的降低了用户的体验度。

完成时间：*2018/10/12*

***

任务描述：进度依旧，学习了MySQL的一些内容，将整个服务器后台大改，调整MySQL数据库的结构，并改变相应的逻辑代码，调整数据类的构成成分，让代码更加简洁，调整CURD的操作方式，设置图片服务器路径，实现图片的远程上传和访问，大大减小了app的体积和冗余度。

完成时间：*2018/11/5*

***

任务描述：项目中开始有意识的使用一些设计模式，最常用的是工厂模式，单例的双重锁定模式，外观模式，有意识的开始封装一些包构成完整的工具类，也许会随着时间的增加，包的内容和质量不断上升。同时完成了地图的寻宝实现，并在客户端的sqlite数据库和远程数据库实现数据的完整交互。

完成时间：*2018/11/27*

## 五.Bug板块

> Bug板块记录了我在开发过程中遇到的问题，也见证着自身知识点逐渐完善的过程。

Bug原因：Icon设置大小未调节

Bug类型：`OOM + Launcher3 has stopped`

Bug解决时间：*8/10/2018*

***

Bug原因：主fragment向activity建立依赖not work,原因是没有调用一个自定义的`newInstance`的实例。

Bug类型：`没有报错+fragment切换失效`

Bug解决时间： *8/18/2018*

***

Bug原因：进入社交页面，PullToRefreshView一直在刷新，无法取消刷新状态，调试也无法进入相应的触点函数。

Bug类型：`PullToRefreshView一直刷新无法取消`

Bug解决时间：8/25/2018

***

Bug原因：在button的setOnclick函数中先开启了Loading框，然后通过一个new Thread()中进行耗时操作，再在new Thread()完成后，实现Loading框的取消，但是这里没有考虑到new Thread()包括AsnyckTask都是异步的操作，所以这里的开启Loading和取消Loading的操作实际上是相当于上下衔接的，之间没有间隔时间，所以看起来就是Loading没有开启的效果。便想到了第二种方式：通过Thread.currentThread().sleep(time);模拟耗时的操作，直接让当前线程沉睡，但是又导致了微弱的ANR，因为Button的响应速度非常缓慢，导致Loading的开启只有非常短暂的时间，实则也不可取。

Bug类型：`button中的setOnClick中设置耗时操作时，刷新页面无法正常启动`

解决方案：这个问题比较特殊，所以这里贴上解决方案，直接通过setOnTouch()方法来代替原本的setOnClick()方法，直接在其中捕捉button的按下和弹起两个基本事件，我们在button按下的一瞬间显示Loading加载框，在button弹起的一瞬间开启网络操作，并在这个时候使用上面第二个方法中的Thread.currentThread().sleep(time);让当前主线程来休眠一个不超过5s的时间，这个时候button已经被点击完毕了，所以微弱的ANR不会对button本身产生影响，问题成功解决。

Bug解决时间：*2018/9/22 *

***

*9/24/2018*

Bug描述：在Presenter的事件监听中，不能直接在子Thread中使用Toast的方法，必须新创建一个子线程，然后才能在子线程中调用Toast方法，注意要给子线程一个Handler地循环机制。

Bug类型：`网络请求完毕后，没有相应地用户提示，并且activity异常崩溃，由于输出管道地损坏，没有报错信息地显示`

Bug解决时间：*9/25/2018*

***

Bug描述：`在使用环信的获取好友列表的功能的时候，返回错误:Unknown_server_error，无法正常获取当前用户的好友列表`

Bug解决措施：只需要将对应的ECAPI放入一个子线程中就可以完成对于当前用户好友列表的获取了，具体原因不明。

Bug解决时间：2018/10/4

***

Bug描述：`在Application中查找并向MoonStep_Palace中添加User对象的时候，由于是网络请求的缘故，传给List的数据会很慢，这样的话，Recycler中地adapter会逐渐刷新界面，然而，由于List尚未完全完成对于数据地请求操作,所以此时看来RecyclerView中地数据只能显示一部分，处理地方式是什么呢？`

Bug解决措施：已经解决，解决方式：在第一次加载的时候，将好友的信息存储到SQLite中，一方面减少对网络请求的依赖，递增速度，第二个是在好友页面直接从本地数据库中加载的话，比从网络上重新加载要快了许多。

Bug解决时间：2018/10/12

***

Bug描述：在tomcat配置的后台中，使用Servlet接收中文数据的时候出现了乱码问题，但是之前测试的时候中文是可以正常显示的，然后尝试
`request.setCharacterEncoding("utf-8")`和`response.setContentType("text/html;character=utf-8")`都没有什么用处。

Bug解决措施：在接收数据的时候，先解码然后译码，将tomcat本身支持的ISO-8859-1的编码方式转换为UFT-8的编码方式，经测试，问题成功解决，语法具体如下:

`String xxx = new String(request.getParameter("xxx").getBytes("ISO-8859-1"),"UTF-8").trim();`

Bug解决时间：2018/11/15 

***

Bug描述：在向远端数据库存储当前所在的位置经纬度的时候，用的网络请求框架Volley返回的Response为""，而使用okhttp3没有得到正确的回调，为了检测错误的原因，使用postman进行数据的传输，但是postman中可以得到正确的结果返回。

Bug解决措施：postman可以得到正确的结果回调，这说明bug问题并不是后台的Servlet出了问题，那为什么android端使用的框架就不能得到正确的结果回调呢？一开始怀疑是框架自身的问题，于是把Volley换成了okhttp3，不行，又把okhttp3换成Fast Fast Android Networking，结果还是不行，这个时候报出来一个JSON异常，大致就是说回调的内容为""，而不是null，然后又把android端的数据放到postman中再次测试，没有结果回调！最后探查是路径参数打错了。。。

Bug解决时间：2018/11/26

***

Bug描述：安装应用的时候，报错：Error: Activity class {priv.zxy.moonstep/priv.zxy.moonstep.guide.GuidePage} does not exist.

Bug原因：因为在系统中数据包没有删除干净（只从桌面删除应用不够），必须通过命令完整删除包

Bug解决措施：在temminal中施加以下命令:adb uninstall xxx.xxx.xxxxxxx

Bug解决时间：2018/11/27

***

Bug描述：背包界面物品显示不全

Bug原因：GridView和ScrollView嵌套使用时，不能支持adapter的数据适配，只能适配到第一条数据

Bug解决措施：去掉ScrollView，此问题是Google的Android系统设计的缺漏，不能更改源码的情况下，没有找到解决方案，只能去掉ScrollView。

Bug解决时间：2018/12/09

***

Bug描述：月友界面的背包dialog不能适配gridView中的数据

Bug原因：当使用dialog的show来显示数据的时候，才开始进行的数据适配，动态的给gridView增加item，追寻了一下源码发现数据源追踪到了PhoneWindow的addView函数里面，然后猜想应该是不会允许动态增加布局，受到了某种条件的约束。

Bug解决措施：增加初始化数据类，统一所有需要初始化的数据调用，并在登陆成功的时候，获取所有的数据，就像用户的个人信息，又或者是用户的物品信息，并将其存储在垃圾堆中的相应数据对象中，有点像备忘录模式，来用一个类暂存数据，之后取数据的时候，直接从对象中取，效率就会很高。

Bug解决时间：2019/01/06

## 六.应用层设计

### 项目整体UML类图

### 设计模式

>在学习完常用的二十几种设计模式以后，将整个项目的UML类图构建出来，并用合适的设计模式进行处理，这里面有些细节用了很巧的方式来实现，这里我想记录一下。

### 权限设计

在圆月行中，权限是它围绕单个用户展开的核心机制之一，构建一个合适的全系统便成为了重中之重的事情，我是怎样构建这个权限系统的呢？

一开始没有很多想法，简单设计了一个权限抽象类，它的下面应该有两个抽象类，一个是永久性的权限抽象，而另一个是偏重于功能/奖励类的抽象，这两个抽象构成整个权限系统的基类，所有的权限子类将全部通过继承的方式围绕着两个抽象类展开。

然后利用工厂模式封装选择的过程，因为为了满足OCP和单一职责原则，我们将单个的权限视为一个单独的类，每次只要产生新的权限，就不必对原有的类进行修改，而是直接通过工厂模式来封装子类选择的过程。

当实现对应的细节的时候，我们希望客户端只要输入对应的权限码，就可以得到相应的返回对象，而这里一开始是想用简单抽象+反射的思想来减少which的使用，然而我们传入的是权限码，java并没有办法通过反射得到权限码的对应权限对象。

因此我们需要一个map来存储这种映射关系，而这个map的位置放在哪里成为了关键。

我们发现，不论是永久权限抽象又或者是功能权限抽象，它们的基类数据实质上都包含这样一个映射关系——<权限码，权限类名>

所以我们将这个映射关系直接集成在它们的父抽象类中————AbstractFactory，直接用一个HashMap存储所有的权限关系，存储的过程放在父类的构造函数中，也就是说，只要我们不调用这个工厂类，就不会产生这样一个庞大数据量的hashMap的对象，降低了资源的损耗。

由于是集成关系，直接在子类中调用就可以了。

## 七.版本控制

该项目使用Git作为版本控制工具，您可以在branch中看到当前当前的可用版本。

## 八.贡献者
- zxy
- lyj

