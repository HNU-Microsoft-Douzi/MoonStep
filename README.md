## 圆月行
![](https://i.imgur.com/UzmuUvx.png)

圆月行基于Java进行开发，开发时间从2018年8月10日至今。

该项目的构建主要有如下几个目的：

- 第一个按照自己想法构建的开源项目
- 上线应用商店
- 熟悉Android体系和Java体系的知识点，提升代码操作的熟练度

项目分为了两个服务后台和一个客户端，客户端和后台的主要业务逻辑由我负责进行开发，后期加入了在校小伙伴LYJ，业务逻辑详见下面的模块开发板块。

至今为止构建的代码量超过35000+行，技术点包括四大组件，UI构建，简单的自定义View，网络编程等。

开发过程中遇到了无数bug，部分在Bug记录模块有所记录，部分归纳成博文放在博客页面-->[张晓翼的博客](https://www.zxyblog.xyz)

## 一.功能介绍

这里配合图文介绍项目的主要功能

功能展示：

![](/display_image/gif_1.gif)

您在上述gif中可以看到启动页，地图寻宝页面，社区分享页面和消息列表页面，他人信息页面的展示。

我用最简洁的动画效果展现圆月行的主体，地图寻宝页面需要对您的当前位置进行一个定位来实现圆月行的核心功能，您会在地图上看到随机生成的32个寻宝点，这些点是随机生成的，并且每隔3天会刷新一次，当您靠近任意一个点距离在50m范围之内的时候，您就可以按下屏幕上的指纹图标进行检索，当圆月行检测到的确有寻宝点在您的身边50m之内，圆月行会对对应的坐标进行清除，并将对应点的宝藏奖励给您，作为外出寻宝的一点小小诚意。对了，这32个点生成的宝藏都是随机的，这些宝藏有各种东西，您可能会得到某些人的联系方式，又或者您会得到一定的实物奖励，最常见的就是等阶在二三阶的道具了（我们的道具设定总共有十阶，等阶越高，权限越大哦~），当然，您在寻宝的过程中，如果发现了十分美丽的场景是之前不曾注意到的，您在领取奖励的同时，可以将您所在地点的照片甚至是视频分享给到圆月社区中，当您分享的地点得到了足够多的点赞后，该地点会升级成为热门寻宝点，您将有机会抽取高阶道具，同时，会引发额外的彩蛋。

![](/display_image/gif_2.gif)

您在上述gif中看到了宝物投递页面，旋转按钮，弹出你的道具栏，扔进不同的道具，会有各种不可思议的功能哦~（虽然我搭建好了功能模块的架构，但还没有丰富细节~）

与此同时，您可以在消息页面中向好友发送消息，我设置了开机自启和后台保活（省电白名单），所以您可以在开机的过程中接收到来自好友的消息，那会以通知的形式显示在您的通知栏上方，当您进入展示页面的时候，如果有新的消息提示，会在您的下方导航栏中的月友图标中有所呈现，那会让月友图标手中的心变成红色，当然，进入到月右界面后您可以看到相应的消息提示，并且红色的心会再次暗淡下去。

![](/display_image/gif_3.gif)

您在上述页面看到了一个多功能展示页面，整个app的主要功能将全部在这里显示，您可以在该页面查询每天随机产生的日常任务，针对完成会有不同奖励（虽然后台数据我还没有写好~），您还可以在该页面看到您的一个宠物信息，种族信息，和已经获得的道具信息（或许为了商业目的我会引入三方支付SDK构建商品页面~），您还可以在该页面进行一个消息的反馈，我们会在后台接受到您传递的数据。当您感觉数据占用缓存过多时，您可以对空间进行清理，同时您也可以在称号选择页面选择您所喜欢的称号，当然，不同的称号，不同的种族，不同的宠物，会给您的探索功能和社交功能带来完全不同的增益效果，我设定了完全的道具机制，各种道具可以在圆月行中获得其它app中难以想象的权限。


**当然，由于设计的时候没有考虑整个体系的庞大程度，虽然至今我完成了近乎70%的作业度，但还是有30%（10%的优化，10%的细节，10%的后台数据量）会在接下来的几个月的时间内逐步完善，圆月行会争取在7月份之前上架应用商店，如果顺利的话，我会下定决心，并为之付出一些代价。**

## 二.三方依赖

- MobSDK
- 高德MapSDK
- 环信SDK（后期将剔除对于环信的依赖，自己搭建聊天通讯后台）
- CircleImageView
- RecyclerView
- FanLayoutManager
- CardView
- Volley
- Material-Dialog
- LitePal
- ENViews
- Fast Android Networking
- Gson
- LeakCanary
- Ucrop
- Glide
- RxJava
- Retrofit
- AsynHttp

## 三.模块开发（部分40%）

### 登陆注册

业务逻辑的开端，也是最早学的时候写的模块，那个时候有很多东西考虑不全，也没有面向OO编程的思想和意识，写了一大堆重复的代码，但是重构需要成本，不打算重构了。

登陆注册的逻辑主要是利用手机号码发送一个短信并进行验证，验证的逻辑是只要之前没有进行过注册，就可以进行注册，用户登陆账户==手机号码，账户保存在后台数据库中，每次登陆的时候向数据库发送登陆请求，接收到验证后，登陆成功。

注册逻辑中，在验证了手机号码以后，你要随机的设置一些账号的必要信息，然后注册成功的时候服务器会给你随机分配一个职业，当前应用设定的显示职业有五个，分配的职业会用自定义Dialog的形式呈现出来，种族Dialog除了数据适配外，同样需要进行图片适配，图片的数据不才用流的方式直接传递，而是传递服务器端对应的种族图片的地址，然后用Glide框架进行加载。

（按照原来的设定，不同的种族会采用不同的机制，譬如，最基本的就是每天能够随机获得的东西是不同的... ...由于时间和精力关系，无法将这部分的逻辑付诸实现，只能待以后再进行。）

**产生问题:**

登陆注册页面主要出现了以下问题：

- 短信的验证该让谁去对用户发送消息，发送的验证码又该怎样产生？如何校验？
- 用户在登陆和注册的时候，如果网络比较卡顿，如何在保证体验度的情况下，让用户耐心等待？
- 因为有聊天模块的存在，我该怎样进行一个双服务器登陆的同步工作？
- 考虑特殊情况，如果我之前登陆成功，那么我下次登陆就不需要再次进入登陆界面，而是直接进入主界面，这种标记信息我该如何进行存储？
- 接上述情况，如果我之前登陆失败，那么我需要考虑上次是否登陆成功，如果是，我该怎样让下次登陆不再直接进入主页面。

**解决方案：**

针对上述问题，我思考良久，权衡利弊，没有去自己再写一个短信发送的后台，直接调用了三方的接口，MobSDK，用自己的页面将接口逻辑适配。

为了保证用户的体验流畅度，我加了一个灰度背景的旋转加载图片，让用户知道当前正在请求网络，为了避免按下Button加载旋转图片的时候产生卡顿，我将网络操作和加载的动作放在了子线程中，但是我现在记得当初子线程中去加载图片，因为子线程不允许UI的修改，这让我不得不去了解Handler机制怎样进行消息的传递。

双服务器的同步，我分了两个部分，一个是登陆请求，一个是下线请求，我将两个部分的逻辑分别放在login的网络请求和Application中，实现服务器之间用户数据的一个同步作用。

对于登陆的标记信息的问题，我利用了SharedPreference来缓存信息，保存数据，对不同的情况进行枚举，如果发生，我就通过SharedPreference改变磁盘上的存储数据，为了便于整个项目的操作，我将SharedPreference按需封装为了一个数据缓存库，为了便于代码的维护，我将该库的Api调用通过外观模式封装了一个工具类SharedPreferenceUtil，简化维护的代价。

### 图片上传

本来计划是将图片上传模块封装成一个组件的，时间原因，只能等第二周完了再解耦。

图片上传模块的细节难点在于图片和服务器两端的数据传输和数据接收的一致性，我先做服务端的图片处理，逻辑是通过利用ServletFileUpload对数据请求进行解析，解析的结果存入一个List的列表中，它的泛型参数是FileItem，然后利用一个for循环看当前解析出来几个item，然后在for循环中对fileItem的属性方法进行解析，比如文件的名称之类的，这里我在数据端上传的时候，直接将文件名称定义为用户账号，这样存储的时候，我就可以通过解析名称获得图片的存储地点，而不用再去传递参数请求，实际上我发现如果用流进行文件上传的话，好像是不能附带参数的，我试过了解析失败，于是就采用了另外的思路避开了之前的方案。

当我在for循环中对数据解析完毕后，我就动态组装存储路径，然后用文件流的方式向对应文件进行写入。

当我在Windows平台上利用postman进行数据测试，提交了form-data数据的文件，然后成功上传，得到服务器的返回，我知道了form-data应该也是采用的二进制方式上传文件。

这个时候我开始准备客户端的上传方式，我隐隐感觉其中有点问题，但开始写的时候并不知道问题在什么地方。

最后才知道，最大的问题，在于图片传输过程中，如果传入的数据和服务端解析的数据不相同，哪怕错一个字节，也会导致解析失败，出现虽然有文件，但是文件格式错误的情况。

我经过多次尝试，最终发现了一个名叫AsyncHttpClient的框架，这个框架有个最大的特点，就是它的params可以直接传入键值参数，所以，我直接将我处理后的图片（下面会说处理的方式）通过File和键值对的方式充当上传的参数，经过测试，可以成功上传。

对于图片的处理方式，我必须去先通过PoupWindow定义出来一个弹窗，然后弹窗页面上有三个按钮，一个从图库中选择，一个从相机中选择，一个取消选择。

可这里还有个问题，我直接回调系统图库或者系统相机确实实现非常简单，但是用户要修改自己的图片总得有一个图片剪裁功能吧，

专门写一个剪裁页面预计时间是七天，选择了PictureSelect框架， 发现这个框架在小米8上直接闪退，去github提了issue也没有解决，只能去寻找另外的图片剪裁框架，最终找到一款名为Ucrop的剪裁框架，然后我在onActivity中回调图片选择的结果，将选择结果反馈给Ucrop进行剪裁，剪裁完毕，返回到初始页面，再次判断回调结果，并将调用得到的图片存储到本地，然后构造本地的存储路径，找到图片路径并将其反馈给网络请求类进行解析处理，剩下的过程就是上述所说了。

### 数据初始化

我利用外观模式修饰了一个数据Manager类DataInitManager，封装了对于不同数据的同一接口的调用。

我尽可能的想要满足开闭原则，但最多只能保证让数据初始化类尽可能小的修改，不能完全不修改。

每当有新的数据需要进行初始化，还是要封装到DataInitManager内部，不过除了破坏了些许的开闭原则外，对于可维护性和可复用性是满足的，因为我增加新的需求，不需要过多的对代码进行改动，只需要增进一行api统一调度就可以了。

为了满足业务逻辑，我不能在app开始运行的时候就开始页面的初始化，考虑到必须登陆成功才有必要进行一个数据的请求，我在Application中监听了MainActivity的流程，当我的LoginActivity进入以后，判断到MainActivity进入到了OnCreate()的时候，我才开始进行数据的初始化。

我对数据的请求分为了三层，就像传统的图片三级存储一样，我也对数据进行了三级存储。

每当进入页面的时候，我会先去判断内存中有没有我存的数据的对象，如果没有的话，我就会申请去应用包的文件中进行数据的调用解析，方式直接利用了SharedPreference，接下来继续进行判断，如果文件中还是没有数据，那么我会通过网络框架向远端发送请求，请求获取相应的数据信息。

这里我将SharedPreference用外观模式封装成了一个数据存取类，内部，根据项目的特点，我利用简单工厂封装成了一个简单的数据处理库。

### 即时通信

即时通信模块我是基于换新三方的服务器建的，但我并没有直接调用它写好的那个easyUI版本，我还是比较喜欢自己从零实现。

但是如果要自己从零开始搭建一个聊天后台，代价会很大，衡量了一下时间成本，觉得这样做并不划算，选择之下决定使用双后台的方式进行客户端的通信。

在登陆的时候进行双后台的同步校验，只有都登陆成功的时候，才可以开始数据初始化模块。

同时向换新的服务器监听后台是否有消息来临。

**即时通信模块的难点并不是说我用了三方，然后几行代码一键搞定，它真正的难点在于下面几个问题：（难度依次递增）**

- 我该怎样获得离线消息？
- 我该怎样获取对方的状态？并根据对方是否在线来改变我的界面显示？
- 我该怎样获得在线消息？
- 我获得离线消息以后我该怎样进行存储？
- 我获得离线/在线消息以后我该怎样对用户进行提示？
- 加入我将离线消息存储到数据库中，我该定义怎样的规则来持久化存储又不让数据太多导致太占空间？我是否需要定时对一些过久地数据进行清除？清除的策略是什么？——用LRU吗？
- 如果我当前处于不同的页面，我该怎样对用户进行提示？如果我不在当前的主页面，我是否要用通知来进行？——这是为什么自定义通知库产生的原因。
- 对上一个问题，还有诸多衍生问题：
- 有三种情况：

	1. 用户在月友页面
	2. 用户不在月友页面
	3. 用户在聊天页面

为了让游览者清晰的知道这三者中的问题，我会一一进行阐述。
当我在月友页面的时候，情况最为简单，因为这个时候我只需要知道是谁发送的消息，然后我在判断当前接收到消息的个数，然后找到对应用户的item，然后在对应item的消息显示位置显示相应的消息个数。但是，如果有多个用户同时发送了消息呢？我需要记录他们所有人分别发送的消息个数，这其实也很简单，现在看来，我只要构建一个管理类MessageManager，来管控收到的消息，并用一个ConcurrentHashMap进行消息的存储，为什么要用到ConcurrentHashMap呢？为了保证并发线程对于数据的并发更新。

然后第二个问题，我不在月友页面，假设我不在月友页面，我需要去保证两个元素：对于月友界面下标元素的更新和进入以后对用户消息的提示。还有就是多用户问题，上面已经说过了，这边就不再阐述。当我不在月友页面的时候，我希望下标栏会有一个红色的提示，然后当我点击了月友按钮的时候，不论我是否查看消息，我都要求月友图标上的红色不再显示。

第三个问题，我在聊天页面，
如果我当前正在和别人进行聊天，然后对方给我发送了消息，我必须保证对方的消息可以立即发送到我的窗口，这里面又延伸出来许多问题，下面再说。然后我不能让界面外月友的图标再次加上红色提示，我甚至不能让用户对应的item也产生相应的提示，因为此时消息我已经看过了。

上述遇到的问题，涉及到了数据的存储（缓存+SQLITE），Activity与Activity的通信，Activity与Fragment的通信，与服务器的交互，数据信息的适配，并发条件下数据的安全性，RecyclerView,Service（要在后台来接受消息）的使用，Service和Fragment交互，最难的是逻辑上的思路问题，思路的解决策略就是枚举。

（其实这里是可以用EventBus的，但是前期写项目的时候刚接触，什么都不懂，不会用框架，后期维护起来成本又太高，就暂时搁置了）

### 地图模块

地图微模块是整个圆月行的核心，因为它的设计理念就在于用户放下手机，走出房间，出外寻宝，去寻找身边不曾发现的景物。

逻辑实现：
我要在用户对应的界面上显示一个地图，然后让地图上呈现32个坐标，以用户为中心点散步到他周围30公里内，每当用户走到距离最近的一个点，就可以按下指纹触碰进行检测，然后通过距离最小点的检测算法检测当前用户距离目标点的确是最小的，那么此时要做的事情有如下几件：

- 跳出一个dialog，来呈现该地点应该给予用户的道具奖励。
- 将dialog中的奖励同步到服务器，同步到内存，同步到本地，同时修改背包中的缓存数据。
- 将地图上对应的寻宝点进行删除，并对整个View进行刷新。
- 分配在这32个点的奖励来源从服务器中获取，该怎么做？

自定义地图对我而言是一件很困难的事情，所以我了解了百度地图的SDK，发现它不支持自动设点，这有违我的应用逻辑，我又找到了高度地图的SDK，看完它的技术文档，发现高德地图的自定义能力十分出色，我设定了几个地图的主题，希望用户得到相应的道具以后可以动态的改变当前地图的样式，这被我作为奖励环节的一个道具存在了数据库中。

而所有点的奖励信息，我在用户登陆页面以后就在初始化管理类中进行了调用，我一次性请求所有的奖励物品，当用户进入地图页面的时候，我就按照一定的规则将这些奖励道具分配在32个点上，同时将奖励信息适配每个点的显示信息，这样我就完成了地图中最困难两个问题的解决。

### 算法家族

整个项目用到算法的地方不是很多，毕竟只是客户端，然而还是在地图板块用到了一些算法，比如以一个经纬度中心点随机生成32个经纬度坐标，然后将这些坐标显示在地图模块上，又比如检测现在距离自己最近的点，并返回距离，看和设定的探查距离是否相同。

我直接用策略模式封装了个算法家族，有新算法的时候直接向里面加就好了。

结构如下:
![](https://i.imgur.com/6V0tPmg.png)

### 内存泄漏处理

关于内存泄漏，一开始并不了解，但是一次灾难重大的事件导致我不得不对内存泄漏或者说OOM引起重点关注，18年8月份的时候，我无意中将一个3000*3000像素的图片作为了整个Activity的icon图标，我相信很多人都没有注意这会引发多么可怕的事情，它几乎摧毁了我两个手机的操作系统，oppo和华为的，两个手机的Launcher被严重损坏，哪怕重启或者恢复出厂也没有用处，至今哪怕了解了Android启动流程我也不能完全肯定到底是哪里出现了问题，仔细分析一下，我猜想可能是Launcher向AMS发送消息的时候，icon中庞大的像素导致Launcher启动失败，影响的范围不仅是每个app的沙盒环境，估计是导致底层的AMS服务出问题了，所以整个界面直接崩溃，最后用三天+两台手机+数十个虚拟机的崩溃查明了原因，解决了问题。

然后就内存泄漏问题进行了了解，开始并不理解原理，也是最后熟悉了JVM以后，才知道里面的一些原理。

简单来说，内存泄漏就会导致OOM,OOM就会导致应用崩溃。

说说我对内存泄漏的处理经验：

- 线程引起的Activity泄漏，主要原因是因为Activity在onDestroy的时候，线程的Runnable对象持有外部Activity的引用，所以此时Activity的资源不能被释放，解决办法就是将Runnable构建成静态内部类，然后用这个类的对象创建线程的对象解决引用问题。

- 单例引起的Activity泄漏，有的时候写某些工具类的时候要用到单例，需要传入一个Activity的实例，这会导致我们在Activity结束的时候并没有清理Activity的引用，解决的策略也很简单，就是在Activity的OnDestroy里面完成Activity实例的清理。

- Handler匿名内部类造成的内存泄漏，这关于Handler的底层原理，Handler中会持有创建它的线程的一个实例，并且当我们关闭Activity的时候，Handler中的MessageQueue仍旧会持续8s钟的时间，解决办法就是利用静态内部类不会持有外部类引用的属性来将Handler处理为静态内部类就可以。

- 有的时候会需要在Activity关闭的时候也执行异步的任务，如果不用Service的话，解决方法就是在Activity的onDestroy中执行线程的创建。 

- 再一个就是各种资源、属性动画、广播的开闭，注意控制。

### MVP架构模块

对部分逻辑模块采用了MVP的架构模式，比如commerce模块和login模块。

Android本身的Activity组件化程度很高，也注定了Android生来就是mvc的架构模式，但Activity相当于Controller去控制View和逻辑的交互，但这样出现了很大的问题，因为控制视窗显示不单单是一个xml文件可以做到的，甚至于有的时候要动态的变换窗口或者说监听各种事件，我们不得不把控制视图的代码写到Activity中。

应用MVP是因为多了中间件Presernter来代替Controller的作用，实现逻辑和View的强解耦，这个时候Activity我们把它视作View，将界面操作的逻辑放在Activity内部，逻辑实现放在module层，module层和View层不能直接进行通信，而是通过全持有presenter的引用来建立联系。

但是真正构造完以后发现缺点也非常明显，MVP将迪米特法则发挥到了极致，几乎是离不开接口，我不得不多写很多类来帮助进行MVP的架构，这很大程度上的增加了工作的负担。

## 四.开发流程

> 您可以在这里看到项目的整个开发流程

任务描述：项目构建完成，初始化设计理念，构想完整的页面逻辑，并利用工具（墨刀）开始打造圆月UI界面。

完成时间：*7/31/2018*

***

任务描述：墨刀打造UI界面基本完成，未进行效果优化，开始编写结构代码。

完成时间：*8/4/2018*

***

任务描述：引导页+登录页面基本完成，注册页面完成，注册功能尚未完善，预计引入第三方登录（QQ、微信和微博登录）。

完成时间：*8/12/2018*

***

任务描述：主页面架构大体完成，利用Fragment嵌套和切换，实现侧滑菜单中的菜单项共联，构想六层菜单栏。

完成时间：*8/15/2018 *

***

任务描述：面对抽象的架构完成，开始面对细节的设计项目。

完成时间：*8/18/2018*

***

任务描述：聊天页面搭载完成，暂定客服页面使用聊天页面的窗口，数据的传输尚未实现，平台架构尚未搭建好，预计一个月内实现数据的上传和交互。

完成时间：*8/21/2018*

***

任务描述：背包界面设计完成，采用网格布局，内置功能尚未完成，方格采用ImageView的组件实现，物品栏目使用前景进行填充，并对每个item进行监控，点击后进行弹窗，尚未进行设置。

完成时间：*8/23/2018*

***

任务描述：解决Butterknife与android 3.0冲突的问题，成功使用Butterknife Zeleny插件，减少了每个页面要写findViewById()的冗杂。

完成时间：*2018/9/6*

***

任务描述：使用Mob平台的短信SDK，动态架构进需要使用的gradle配置层，并且在登陆页面实现手机验证的功能。（后期经过验证，mob的SDK在编译时会占用大量的时间，实质上mob页面已经完成，但是sdk不大稳定，有自己实现短信验证的打算，但是与第三方(电信，联通，移动)交互过于麻烦，暂且搁置。）

完成时间：*2018/9/7 *

***

任务描述：使用mvp架构模式对整个项目进行重构，将所有文件区分为区块-逻辑块(Module) + Presenter(桥街块) + View（视图）三块
实现逻辑和视图的高度欠耦合，presenter中间件的作用明显，但是没有用到其它的设计模式导致整个项目的架构看起来还是有些冗杂。

完成时间：*2018/9/16-22*

***

任务描述：有意识的使用动画开始改进当前项目的显示下过，改进所有按钮点击的效果，不再通过来回的改变TextView的Size大小或者改变button本身的颜色来达到点击效果，而是通过button的晃动效果实现用户的优良体验，但是没有规范化各个显示组件的样式和动画模式。

完成时间：*2018/9/21*

***

任务描述：Login-MVP架构模式完全完成，对mvp架构模式逐渐有了自己的理解。

完成时间：*2018/9/25*

***

任务描述：开始实现社交板块，社交板块计划用环信的SDK，并在接下来的几天中完成了对环信SDK的搭载和接入（ps:环信的服务器端和客户端接口做的很不错，token的设置也的确一定程度上的保障了用户数据的安全性，唯一缺陷是价格过高，如果不升级为专业版本就无法上市[因为社区版本最多只有100个用户的注册名额]）

完成时间：*2018/10/1*

***

任务描述：消息接收流程尚在处理，对于用户大量网络数据的保存计划集成在本地的sqlite数据库中，计划使用开源库:GreenDao数据库框架对用户的好友等信息进行保存，理由是每次从网络上获取好友的信息太过耗费时间，也耗费流量，极大程度的降低了用户的体验度。

完成时间：*2018/10/12*

***

任务描述：进度依旧，学习了MySQL的一些内容，将整个服务器后台大改，调整MySQL数据库的结构，并改变相应的逻辑代码，调整数据类的构成成分，让代码更加简洁，调整CURD的操作方式，设置图片服务器路径，实现图片的远程上传和访问，大大减小了app的体积和冗余度。

完成时间：*2018/11/5*

***

任务描述：项目中开始有意识的使用一些设计模式，最常用的是工厂模式，单例的双重锁定模式，外观模式，有意识的开始封装一些包构成完整的工具类，也许会随着时间的增加，包的内容和质量不断上升。同时完成了地图的寻宝实现，并在客户端的sqlite数据库和远程数据库实现数据的完整交互。

完成时间：*2018/11/27*

***

任务描述：对项目中的200+个内存泄漏的引用进行清理，最常见的是Fragment中申明的view布局没有被清理和使用匿名方式声明的Handler引用变量。

完成时间: *2018/12/27*

***

任务描述：对项目整体进行重构，对界面大幅度整改，去掉引导页面，去除策划栏，增加首页分享按钮，优化事件监听的代码实现，采用接口代替匿名内部类，提高可读性。

完成时间：*2019/03/04*


## 五.Bug板块

> Bug板块记录了我在开发过程中遇到的问题，也见证着自身知识点逐渐完善的过程。

Bug原因：Icon设置大小未调节

Bug类型：`OOM + Launcher3 has stopped`

Bug解决时间：*8/10/2018*

***

Bug原因：主fragment向activity建立依赖not work,原因是没有调用一个自定义的`newInstance`的实例。

Bug类型：`没有报错+fragment切换失效`

Bug解决时间： *8/18/2018*

***

Bug原因：进入社交页面，PullToRefreshView一直在刷新，无法取消刷新状态，调试也无法进入相应的触点函数。

Bug类型：`PullToRefreshView一直刷新无法取消`

Bug解决时间：8/25/2018

***

Bug原因：在button的setOnclick函数中先开启了Loading框，然后通过一个new Thread()中进行耗时操作，再在new Thread()完成后，实现Loading框的取消，但是这里没有考虑到new Thread()包括AsnyckTask都是异步的操作，所以这里的开启Loading和取消Loading的操作实际上是相当于上下衔接的，之间没有间隔时间，所以看起来就是Loading没有开启的效果。便想到了第二种方式：通过Thread.currentThread().sleep(time);模拟耗时的操作，直接让当前线程沉睡，但是又导致了微弱的ANR，因为Button的响应速度非常缓慢，导致Loading的开启只有非常短暂的时间，实则也不可取。

Bug类型：`button中的setOnClick中设置耗时操作时，刷新页面无法正常启动`

解决方案：这个问题比较特殊，所以这里贴上解决方案，直接通过setOnTouch()方法来代替原本的setOnClick()方法，直接在其中捕捉button的按下和弹起两个基本事件，我们在button按下的一瞬间显示Loading加载框，在button弹起的一瞬间开启网络操作，并在这个时候使用上面第二个方法中的Thread.currentThread().sleep(time);让当前主线程来休眠一个不超过5s的时间，这个时候button已经被点击完毕了，所以微弱的ANR不会对button本身产生影响，问题成功解决。

Bug解决时间：*2018/9/22 *

***

*9/24/2018*

Bug描述：在Presenter的事件监听中，不能直接在子Thread中使用Toast的方法，必须新创建一个子线程，然后才能在子线程中调用Toast方法，注意要给子线程一个Handler地循环机制。

Bug类型：`网络请求完毕后，没有相应地用户提示，并且activity异常崩溃，由于输出管道地损坏，没有报错信息地显示`

Bug解决时间：*9/25/2018*

***

Bug描述：`在使用环信的获取好友列表的功能的时候，返回错误:Unknown_server_error，无法正常获取当前用户的好友列表`

Bug解决措施：只需要将对应的ECAPI放入一个子线程中就可以完成对于当前用户好友列表的获取了，具体原因不明。

Bug解决时间：2018/10/4

***

Bug描述：`在Application中查找并向MoonStep_Palace中添加User对象的时候，由于是网络请求的缘故，传给List的数据会很慢，这样的话，Recycler中地adapter会逐渐刷新界面，然而，由于List尚未完全完成对于数据地请求操作,所以此时看来RecyclerView中地数据只能显示一部分，处理地方式是什么呢？`

Bug解决措施：已经解决，解决方式：在第一次加载的时候，将好友的信息存储到SQLite中，一方面减少对网络请求的依赖，递增速度，第二个是在好友页面直接从本地数据库中加载的话，比从网络上重新加载要快了许多。

Bug解决时间：2018/10/12

***

Bug描述：在tomcat配置的后台中，使用Servlet接收中文数据的时候出现了乱码问题，但是之前测试的时候中文是可以正常显示的，然后尝试
`request.setCharacterEncoding("utf-8")`和`response.setContentType("text/html;character=utf-8")`都没有什么用处。

Bug解决措施：在接收数据的时候，先解码然后译码，将tomcat本身支持的ISO-8859-1的编码方式转换为UFT-8的编码方式，经测试，问题成功解决，语法具体如下:

`String xxx = new String(request.getParameter("xxx").getBytes("ISO-8859-1"),"UTF-8").trim();`

Bug解决时间：2018/11/15 

***

Bug描述：在向远端数据库存储当前所在的位置经纬度的时候，用的网络请求框架Volley返回的Response为""，而使用okhttp3没有得到正确的回调，为了检测错误的原因，使用postman进行数据的传输，但是postman中可以得到正确的结果返回。

Bug解决措施：postman可以得到正确的结果回调，这说明bug问题并不是后台的Servlet出了问题，那为什么android端使用的框架就不能得到正确的结果回调呢？一开始怀疑是框架自身的问题，于是把Volley换成了okhttp3，不行，又把okhttp3换成Fast Fast Android Networking，结果还是不行，这个时候报出来一个JSON异常，大致就是说回调的内容为""，而不是null，然后又把android端的数据放到postman中再次测试，没有结果回调！最后探查是路径参数打错了。。。

Bug解决时间：2018/11/26

***

Bug描述：安装应用的时候，报错：Error: Activity class {priv.zxy.moonstep/priv.zxy.moonstep.guide.GuidePage} does not exist.

Bug原因：因为在系统中数据包没有删除干净（只从桌面删除应用不够），必须通过命令完整删除包

Bug解决措施：在temminal中施加以下命令:adb uninstall xxx.xxx.xxxxxxx

Bug解决时间：2018/11/27

***

Bug描述：背包界面物品显示不全

Bug原因：GridView和ScrollView嵌套使用时，不能支持adapter的数据适配，只能适配到第一条数据

Bug解决措施：去掉ScrollView，此问题是Google的Android系统设计的缺漏，不能更改源码的情况下，没有找到解决方案，只能去掉ScrollView。

Bug解决时间：2018/12/09

***

Bug描述：月友界面的背包dialog不能适配gridView中的数据

Bug原因：当使用dialog的show来显示数据的时候，才开始进行的数据适配，动态的给gridView增加item，追寻了一下源码发现数据源追踪到了PhoneWindow的addView函数里面，然后猜想应该是不会允许动态增加布局，受到了某种条件的约束。

Bug解决措施：增加初始化数据类，统一所有需要初始化的数据调用，并在登陆成功的时候，获取所有的数据，就像用户的个人信息，又或者是用户的物品信息，并将其存储在垃圾堆中的相应数据对象中，有点像备忘录模式，来用一个类暂存数据，之后取数据的时候，直接从对象中取，效率就会很高。

Bug解决时间：2019/01/06

***

Bug描述：社区页面消息丢失

Bug原因：首页采用四个Fragment显示隐藏的方式来避免数据的丢失，但当进入其它页面返回原页面的时候出现数据丢失的情况，因此猜测是Fragment的lists数据被清空。

Bug解决措施：在CommunityFragment的onCreate()中重新进行数据的初始化。

Bug解决时间：2019/03/13

***

Bug描述：ScrollView + GridView显示不全

Bug原因：两者都是可滑动控件，会引发冲突

Bug解决措施：重写GridView的onMeasure()方法

Bug解决时间：2019/03/13
## 六.应用层设计

### 设计模式

一开始并不了解所谓的OO，对java面向对象也不太理解，不知道多态，继承的重要性体现在哪里，也不知道为什么别人的库调用这么多的接口来进行设计，我为什么想不出来这样的构思方案。

带着这些问题，了解到了一种叫做设计模式的书，最初接触到的就是大话设计模式，这本书特别简单易懂，不得不说是我接触过最好的设计模式启蒙书了。

用了两个周的时间，在学习完常用的23种设计模式以后，知道了常说的四种设计思想，这极大程度的改变了我的代码规范和设计思维模式，为了训练自己对设计模式的掌握情况，我将整个项目的UML类图构建出来，并用合适的设计模式进行处理，这里面有些细节用了很巧的方式来实现，虽然现在看来我不大记得。

这里我会放出类图，并不是整个项目的完整架构，我认为那实在太庞大了，就以基于User类的整个逻辑核心来呈现。

### 项目整体UML类图

![](https://i.imgur.com/t6T4ipo.png)

### 权限设计

在圆月行中，权限是它围绕单个用户展开的核心机制之一，构建一个合适的全系统便成为了重中之重的事情，我是怎样构建这个权限系统的呢？

一开始没有很多想法，简单设计了一个权限抽象类，它的下面应该有两个抽象类，一个是永久性的权限抽象，而另一个是偏重于功能/奖励类的抽象，这两个抽象构成整个权限系统的基类，所有的权限子类将全部通过继承的方式围绕着两个抽象类展开。

然后利用工厂模式封装选择的过程，因为为了满足OCP和单一职责原则，我们将单个的权限视为一个单独的类，每次只要产生新的权限，就不必对原有的类进行修改，而是直接通过工厂模式来封装子类选择的过程。

当实现对应的细节的时候，我们希望客户端只要输入对应的权限码，就可以得到相应的返回对象，而这里一开始是想用简单抽象+反射的思想来减少which的使用，然而我们传入的是权限码，java并没有办法通过反射得到权限码的对应权限对象。

因此我们需要一个map来存储这种映射关系，而这个map的位置放在哪里成为了关键。

我们发现，不论是永久权限抽象又或者是功能权限抽象，它们的基类数据实质上都包含这样一个映射关系——<权限码，权限类名>

所以我们将这个映射关系直接集成在它们的父抽象类中————AbstractFactory，直接用一个HashMap存储所有的权限关系，存储的过程放在父类的构造函数中，也就是说，只要我们不调用这个工厂类，就不会产生这样一个庞大数据量的hashMap的对象，降低了资源的损耗。

由于是集成关系，直接在子类中调用就可以了。

## 七.版本控制

该项目使用Git作为版本控制工具，您可以在branch中看到当前当前的可用版本。

## 八.贡献者
- zxy
- lyj
